{"name":"Base64.java","path":"src/main/java/com/pubnub/api/vendor/Base64.java","content":{"structured":{"description":"an implementation of the Base64 encoding algorithm, which is a way of transforming binary data into a string representation using a subset of the ASCII character set. The code takes in a stream of bytes as input and outputs a Base64-encoded string.\n\nThe main loop of the code iterates over the input bytes, selecting groups of three input bytes at a time to encode as a single output byte. The encoding is done using a lookup table of 64 possible output values, each corresponding to a particular combination of three input bytes. The lookup table is defined in an outer class, and the inner class uses it to produce the encoded output.\n\nThe code also includes several options for customizing the encoding process:\n\n* `do_padding`: whether or not to pad the output with additional '=' characters if necessary to ensure that each line of the output has at most 76 characters.\n* `do_cr`: whether or not to include a CR (carriage return) character at the end of each line of the output.\n* `do_newline`: whether or not to include a newline character at the end of each line of the output.\n\nThe code also includes a `tail` variable that is used to store any input bytes that are left over after the main loop has finished encoding, in case they are needed later for subsequent calls to the `encodeInternal` method.","diagram":"digraph G {\n    label=\"com.todo.FixMe\"\n    bgcolor=\"#151719\"\n    fontcolor=\"#ECEDED\"\n    splines=ortho\n    fontname=\"Courier New\"\n    edge [color=\"#26de81\"]\n}\n","items":[{"id":"ee98ae5a-826a-6394-be46-c5ed8ec68366","ancestors":["af7004e1-bd63-17b0-0b4a-eaeb5bda51ab"],"type":"function","description":"is an abstract class that provides a framework for encoding and decoding data. It has a `output` field to store the coded data and an `op` field to keep track of the length of the coded data. The `process` method takes in input data, offset, len, and a boolean `finish` parameter to indicate if it's the final call. This method returns true if the input is good, and false if some error has been detected. The `maxOutputSize` method returns the maximum number of bytes a call to `process()` could produce for a given number of input bytes.","name":"Coder","code":"static abstract class Coder {\n        public byte[] output;\n        public int op;\n\n        /**\n         * Encode/decode another block of input data.  this.output is\n         * provided by the caller, and must be big enough to hold all\n         * the coded data.  On exit, this.opwill be set to the length\n         * of the coded data.\n         *\n         * @param finish true if this is the final call to process for\n         *               this object.  Will finalize the coder state and\n         *               include any final bytes in the output.\n         * @return true if the input so far is good; false if some\n         * error has been detected in the input stream..\n         */\n        public abstract boolean process(byte[] input, int offset, int len, boolean finish);\n\n        /**\n         * @return the maximum number of bytes a call to process()\n         * could produce for the given number of input bytes.  This may\n         * be an overestimate.\n         */\n        public abstract int maxOutputSize(int len);\n    }","location":{"start":72,"insert":72,"offset":" ","indent":18,"comment":null},"item_type":"class","length":25,"docLength":null},{"id":"a6b22736-64c9-29a7-6f48-8f2a9049a707","ancestors":["af7004e1-bd63-17b0-0b4a-eaeb5bda51ab"],"type":"function","description":"is an implementation of the Base64 encoding algorithm in Java. It takes input bytes and outputs decoded bytes based on a state machine implementation. The class has various methods for processing different blocks of input data, as well as methods to handle the fast path and slow path of the decoding process.","name":"Decoder","code":"static class Decoder extends Coder {\n        /**\n         * Lookup table for turning bytes into their position in the\n         * Base64 alphabet.\n         */\n        private static final int DECODE[] = {\n                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,\n                52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,\n                -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,\n                15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,\n                -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,\n                41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,\n                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n        };\n\n        /**\n         * Decode lookup table for the \"web safe\" variant (RFC 3548\n         * sec. 4) where - and _ replace + and /.\n         */\n        private static final int DECODE_WEBSAFE[] = {\n                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1,\n                52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,\n                -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,\n                15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63,\n                -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,\n                41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,\n                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n        };\n\n        /**\n         * Non-data values in the DECODE arrays.\n         */\n        private static final int SKIP = -1;\n        private static final int EQUALS = -2;\n\n        /**\n         * States 0-3 are reading through the next input tuple.\n         * State 4 is having read one '=' and expecting exactly\n         * one more.\n         * State 5 is expecting no more data or padding characters\n         * in the input.\n         * State 6 is the error state; an error has been detected\n         * in the input and no future input can \"fix\" it.\n         */\n        private int state;   // state number (0 to 6)\n        private int value;\n\n        final private int[] alphabet;\n\n        public Decoder(int flags, byte[] output) {\n            this.output = output;\n\n            alphabet = ((flags & URL_SAFE) == 0) ? DECODE : DECODE_WEBSAFE;\n            state = 0;\n            value = 0;\n        }\n\n        /**\n         * @return an overestimate for the number of bytes {@code\n         * len} bytes could decode to.\n         */\n        public int maxOutputSize(int len) {\n            return len * 3 / 4 + 10;\n        }\n\n        /**\n         * Decode another block of input data.\n         *\n         * @return true if the state machine is still healthy.  false if\n         * bad base-64 data has been detected in the input stream.\n         */\n        public boolean process(byte[] input, int offset, int len, boolean finish) {\n            if (this.state == 6) return false;\n\n            int p = offset;\n            len += offset;\n\n            // Using local variables makes the decoder about 12%\n            // faster than if we manipulate the member variables in\n            // the loop.  (Even alphabet makes a measurable\n            // difference, which is somewhat surprising to me since\n            // the member variable is final.)\n            int state = this.state;\n            int value = this.value;\n            int op = 0;\n            final byte[] output = this.output;\n            final int[] alphabet = this.alphabet;\n\n            while (p < len) {\n                // Try the fast path:  we're starting a new tuple and the\n                // next four bytes of the input stream are all data\n                // bytes.  This corresponds to going through states\n                // 0-1-2-3-0.  We expect to use this method for most of\n                // the data.\n                //\n                // If any of the next four bytes of input are non-data\n                // (whitespace, etc.), value will end up negative.  (All\n                // the non-data values in decode are small negative\n                // numbers, so shifting any of them up and or'ing them\n                // together will result in a value with its top bit set.)\n                //\n                // You can remove this whole block and the output should\n                // be the same, just slower.\n                if (state == 0) {\n                    while (p + 4 <= len &&\n                            (value = ((alphabet[input[p] & 0xff] << 18) |\n                                    (alphabet[input[p + 1] & 0xff] << 12) |\n                                    (alphabet[input[p + 2] & 0xff] << 6) |\n                                    (alphabet[input[p + 3] & 0xff]))) >= 0) {\n                        output[op + 2] = (byte) value;\n                        output[op + 1] = (byte) (value >> 8);\n                        output[op] = (byte) (value >> 16);\n                        op += 3;\n                        p += 4;\n                    }\n                    if (p >= len) break;\n                }\n\n                // The fast path isn't available -- either we've read a\n                // partial tuple, or the next four input bytes aren't all\n                // data, or whatever.  Fall back to the slower state\n                // machine implementation.\n\n                int d = alphabet[input[p++] & 0xff];\n\n                switch (state) {\n                    case 0:\n                        if (d >= 0) {\n                            value = d;\n                            ++state;\n                        } else if (d != SKIP) {\n                            this.state = 6;\n                            return false;\n                        }\n                        break;\n\n                    case 1:\n                        if (d >= 0) {\n                            value = (value << 6) | d;\n                            ++state;\n                        } else if (d != SKIP) {\n                            this.state = 6;\n                            return false;\n                        }\n                        break;\n\n                    case 2:\n                        if (d >= 0) {\n                            value = (value << 6) | d;\n                            ++state;\n                        } else if (d == EQUALS) {\n                            // Emit the last (partial) output tuple;\n                            // expect exactly one more padding character.\n                            output[op++] = (byte) (value >> 4);\n                            state = 4;\n                        } else if (d != SKIP) {\n                            this.state = 6;\n                            return false;\n                        }\n                        break;\n\n                    case 3:\n                        if (d >= 0) {\n                            // Emit the output triple and return to state 0.\n                            value = (value << 6) | d;\n                            output[op + 2] = (byte) value;\n                            output[op + 1] = (byte) (value >> 8);\n                            output[op] = (byte) (value >> 16);\n                            op += 3;\n                            state = 0;\n                        } else if (d == EQUALS) {\n                            // Emit the last (partial) output tuple;\n                            // expect no further data or padding characters.\n                            output[op + 1] = (byte) (value >> 2);\n                            output[op] = (byte) (value >> 10);\n                            op += 2;\n                            state = 5;\n                        } else if (d != SKIP) {\n                            this.state = 6;\n                            return false;\n                        }\n                        break;\n\n                    case 4:\n                        if (d == EQUALS) {\n                            ++state;\n                        } else if (d != SKIP) {\n                            this.state = 6;\n                            return false;\n                        }\n                        break;\n\n                    case 5:\n                        if (d != SKIP) {\n                            this.state = 6;\n                            return false;\n                        }\n                        break;\n                }\n            }\n\n            if (!finish) {\n                // We're out of input, but a future call could provide\n                // more.\n                this.state = state;\n                this.value = value;\n                this.op = op;\n                return true;\n            }\n\n            // Done reading input.  Now figure out where we are left in\n            // the state machine and finish up.\n\n            switch (state) {\n                case 0:\n                    // Output length is a multiple of three.  Fine.\n                    break;\n                case 1:\n                    // Read one extra input byte, which isn't enough to\n                    // make another output byte.  Illegal.\n                    this.state = 6;\n                    return false;\n                case 2:\n                    // Read two extra input bytes, enough to emit 1 more\n                    // output byte.  Fine.\n                    output[op++] = (byte) (value >> 4);\n                    break;\n                case 3:\n                    // Read three extra input bytes, enough to emit 2 more\n                    // output bytes.  Fine.\n                    output[op++] = (byte) (value >> 10);\n                    output[op++] = (byte) (value >> 2);\n                    break;\n                case 4:\n                    // Read one padding '=' when we expected 2.  Illegal.\n                    this.state = 6;\n                    return false;\n                case 5:\n                    // Read all the padding '='s we expected and no more.\n                    // Fine.\n                    break;\n            }\n\n            this.state = state;\n            this.op = op;\n            return true;\n        }\n    }","location":{"start":173,"insert":173,"offset":" ","indent":18,"comment":null},"item_type":"class","length":266,"docLength":null},{"id":"1052beb8-6803-b5ac-8542-be83bce99c0d","ancestors":["af7004e1-bd63-17b0-0b4a-eaeb5bda51ab"],"type":"function","description":"is an internal class in the Java library \"java.util.zip\" that encodes a sequence of bytes into a string using the Huffman coding algorithm. The class has several methods for encoding data, including `encodeInternal` which is the main method for encoding data. This method takes input bytes and outputs the encoded string. It also keeps track of the number of bytes consumed and the number of characters produced, as well as the tail of the input bytes that have not been processed yet. The method uses a loop to iterate over the input bytes and produce the output string, with each iteration consuming 3 input bytes and producing 4 output bytes. The method also handles cases where there are fewer than 3 input bytes available or where the input is empty.","name":"Encoder","code":"static class Encoder extends Coder {\n        /**\n         * Emit a new line every this many output tuples.  Corresponds to\n         * a 76-character line length (the maximum allowable according to\n         * <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>).\n         */\n        public static final int LINE_GROUPS = 19;\n\n        /**\n         * Lookup table for turning Base64 alphabet positions (6 bits)\n         * into output bytes.\n         */\n        private static final byte ENCODE[] = {\n                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',\n                'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',\n                'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\n                'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/',\n        };\n\n        /**\n         * Lookup table for turning Base64 alphabet positions (6 bits)\n         * into output bytes.\n         */\n        private static final byte ENCODE_WEBSAFE[] = {\n                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',\n                'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',\n                'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\n                'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_',\n        };\n\n        final private byte[] tail;\n        /* package */ int tailLen;\n        private int count;\n\n        final public boolean do_padding;\n        final public boolean do_newline;\n        final public boolean do_cr;\n        final private byte[] alphabet;\n\n        public Encoder(int flags, byte[] output) {\n            this.output = output;\n\n            do_padding = (flags & NO_PADDING) == 0;\n            do_newline = (flags & NO_WRAP) == 0;\n            do_cr = (flags & CRLF) != 0;\n            alphabet = ((flags & URL_SAFE) == 0) ? ENCODE : ENCODE_WEBSAFE;\n\n            tail = new byte[2];\n            tailLen = 0;\n\n            count = do_newline ? LINE_GROUPS : -1;\n        }\n\n        /**\n         * @return an overestimate for the number of bytes {@code\n         * len} bytes could encode to.\n         */\n        public int maxOutputSize(int len) {\n            return len * 8 / 5 + 10;\n        }\n\n        public boolean process(byte[] input, int offset, int len, boolean finish) {\n            // Using local variables makes the encoder about 9% faster.\n            final byte[] alphabet = this.alphabet;\n            final byte[] output = this.output;\n            int op = 0;\n            int count = this.count;\n\n            int p = offset;\n            len += offset;\n            int v = -1;\n\n            // First we need to concatenate the tail of the previous call\n            // with any input bytes available now and see if we can empty\n            // the tail.\n\n            switch (tailLen) {\n                case 0:\n                    // There was no tail.\n                    break;\n                case 1:\n                    if (p + 2 <= len) {\n                        // A 1-byte tail with at least 2 bytes of\n                        // input available now.\n                        v = ((tail[0] & 0xff) << 16) |\n                                ((input[p++] & 0xff) << 8) |\n                                (input[p++] & 0xff);\n                        tailLen = 0;\n                    }\n                    break;\n                case 2:\n                    if (p + 1 <= len) {\n                        // A 2-byte tail with at least 1 byte of input.\n                        v = ((tail[0] & 0xff) << 16) |\n                                ((tail[1] & 0xff) << 8) |\n                                (input[p++] & 0xff);\n                        tailLen = 0;\n                    }\n                    break;\n            }\n\n            if (v != -1) {\n                output[op++] = alphabet[(v >> 18) & 0x3f];\n                output[op++] = alphabet[(v >> 12) & 0x3f];\n                output[op++] = alphabet[(v >> 6) & 0x3f];\n                output[op++] = alphabet[v & 0x3f];\n                if (--count == 0) {\n                    if (do_cr) output[op++] = '\\r';\n                    output[op++] = '\\n';\n                    count = LINE_GROUPS;\n                }\n            }\n\n            // At this point either there is no tail, or there are fewer\n            // than 3 bytes of input available.\n\n            // The main loop, turning 3 input bytes into 4 output bytes on\n            // each iteration.\n            while (p + 3 <= len) {\n                v = ((input[p] & 0xff) << 16) |\n                        ((input[p + 1] & 0xff) << 8) |\n                        (input[p + 2] & 0xff);\n                output[op] = alphabet[(v >> 18) & 0x3f];\n                output[op + 1] = alphabet[(v >> 12) & 0x3f];\n                output[op + 2] = alphabet[(v >> 6) & 0x3f];\n                output[op + 3] = alphabet[v & 0x3f];\n                p += 3;\n                op += 4;\n                if (--count == 0) {\n                    if (do_cr) output[op++] = '\\r';\n                    output[op++] = '\\n';\n                    count = LINE_GROUPS;\n                }\n            }\n\n            if (finish) {\n                // Finish up the tail of the input.  Note that we need to\n                // consume any bytes in tail before any bytes\n                // remaining in input; there should be at most two bytes\n                // total.\n\n                if (p - tailLen == len - 1) {\n                    int t = 0;\n                    v = ((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 4;\n                    tailLen -= t;\n                    output[op++] = alphabet[(v >> 6) & 0x3f];\n                    output[op++] = alphabet[v & 0x3f];\n                    if (do_padding) {\n                        output[op++] = '=';\n                        output[op++] = '=';\n                    }\n                    if (do_newline) {\n                        if (do_cr) output[op++] = '\\r';\n                        output[op++] = '\\n';\n                    }\n                } else if (p - tailLen == len - 2) {\n                    int t = 0;\n                    v = (((tailLen > 1 ? tail[t++] : input[p++]) & 0xff) << 10) |\n                            (((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 2);\n                    tailLen -= t;\n                    output[op++] = alphabet[(v >> 12) & 0x3f];\n                    output[op++] = alphabet[(v >> 6) & 0x3f];\n                    output[op++] = alphabet[v & 0x3f];\n                    if (do_padding) {\n                        output[op++] = '=';\n                    }\n                    if (do_newline) {\n                        if (do_cr) output[op++] = '\\r';\n                        output[op++] = '\\n';\n                    }\n                } else if (do_newline && op > 0 && count != LINE_GROUPS) {\n                    if (do_cr) output[op++] = '\\r';\n                    output[op++] = '\\n';\n                }\n\n                assert tailLen == 0;\n                assert p == len;\n            } else {\n                // Save the leftovers in tail to be consumed on the next\n                // call to encodeInternal.\n\n                if (p == len - 1) {\n                    tail[tailLen++] = input[p];\n                } else if (p == len - 2) {\n                    tail[tailLen++] = input[p];\n                    tail[tailLen++] = input[p + 1];\n                }\n            }\n\n            this.op = op;\n            this.count = count;\n\n            return true;\n        }\n    }","location":{"start":548,"insert":548,"offset":" ","indent":18,"comment":null},"item_type":"class","length":195,"docLength":null},{"id":"bb9263fe-f993-bfb9-1c48-853dadd67b73","ancestors":["af7004e1-bd63-17b0-0b4a-eaeb5bda51ab","1052beb8-6803-b5ac-8542-be83bce99c0d"],"type":"function","description":"encodes bytes using a transformation cipher, with input and output buffers, and handles tail processing and new line padding. It returns `true` when finished encoding.","params":[{"name":"input","type_name":"byte[]","description":"3-4 byte array of data that is being encoded.\n\n* `offset`: The starting position of the input in the original byte array.\n* `len`: The total length of the input.\n* `tailLen`: The number of bytes in the tail of the previous call to `encodeInternal`.\n* `alphabet`: An array of 32 bytes, representing the 16 possible values for each of the four bytes in a line.\n* `output`: A byte array holding the encoded output.\n* `op`: The current position in the output array.\n* `count`: The number of bytes remaining to be encoded.\n\nThe function performs encoding on the input bytes, consuming them one at a time and producing corresponding outputs in the `output` array. If the input is fully consumed, the function returns `true`.","complex_type":true},{"name":"offset","type_name":"int","description":"0-based offset into the `input` array where the encoding should start.","complex_type":false},{"name":"len","type_name":"int","description":"total number of bytes to be encoded by the function, and it is used to determine the number of bytes available for encoding each iteration of the main loop.","complex_type":false},{"name":"finish","type_name":"boolean","description":"option to finish the encoding of the input string and produce the final output, instead of leaving it for the next call to `encodeInternal()`.","complex_type":false}],"returns":{"type_name":"boolean","description":"a byte array representing the encoded data, with a certain number of bytes left over for possible consumption on the next call.","complex_type":false},"usage":{"language":"java","code":"public class TestBase64 {\n    public static void main(String[] args) throws Exception {\n        // Using local variables makes the encoder about 9% faster.\n        final byte[] alphabet = Base64.alphabet;\n        final byte[] output = new byte[1024];\n        int op = 0, count = 0;\n\n        // First we need to concatenate the tail of the previous call\n        // with any input bytes available now and see if we can empty\n        // the tail.\n\n        switch (tailLen) {\n            case 0:\n                // There was no tail.\n                break;\n            case 1:\n                if (p + 2 <= len) {\n                    // A 1-byte tail with at least 2 bytes of\n                    // input available now.\n                    v = ((tail[0] & 0xff) << 16) |\n                            ((input[p++] & 0xff) << 8) |\n                            (input[p++] & 0xff);\n                    tailLen = 0;\n                }\n                break;\n            case 2:\n                if (p + 1 <= len) {\n                    // A 2-byte tail with at least 1 byte of input.\n                    v = ((tail[0] & 0xff) << 16) |\n                            ((tail[1] & 0xff) << 8) |\n                                                             (input[p++] & 0xff);\n                    tailLen -= t;\n                    output[op++] = alphabet[(v >> 6) & 0x3f];\n                    output[op++] = alphabet[v & 0x3f];\n                    if (do_padding) {\n                        output[op++] = '=';\n                        output[op++] = '=';\n                    }\n                    if (do_newline) {\n                        if (do_cr) output[op++] = '\\r';\n                        output[op++] = '\\n';\n                    }\n                } else if (p - tailLen == len - 2) {\n                    int t = 0;\n                    v = ((tailLen > 1 ? tail[t++] : input[p++]) & 0xff) << 10 | ((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 2;\n                    tailLen -= t;\n                    output[op++] = alphabet[(v >> 12) & 0x3f];\n                    output[op++] = alphabet[(v >> 6) & 0x3f];\n                    output[op++] = alphabet[v & 0x3f];\n                    if (do_padding) {\n                        output[op++] = '=';\n                    }\n                    if (do_newline) {\n                        if (do_cr) output[op++] = '\\r';\n                        output[op++] = '\\n';\n                    }\n                } else if (do_newline && op > 0 && count != LINE_GROUPS) {\n                    if (do_cr) output[op++] = '\\r';\n                    output[op++] = '\\n';\n                }\n\n                assert tailLen == 0;\n                assert p == len;\n            } else {\n                // Save the leftovers in tail to be consumed on the next\n                // call to encodeInternal.\n\n                if (p == len - 1) {\n                    tail[tailLen++] = input[p];\n                } else if (p == len - 2) {\n                    tail[tailLen++] = input[p];\n                    tail[tailLen++] = input[p + 1];\n                }\n            }\n\n            this.op = op;\n            this.count = count;\n\n            return true;\n        }\n}\n","description":""},"name":"process","code":"public boolean process(byte[] input, int offset, int len, boolean finish) {\n            // Using local variables makes the encoder about 9% faster.\n            final byte[] alphabet = this.alphabet;\n            final byte[] output = this.output;\n            int op = 0;\n            int count = this.count;\n\n            int p = offset;\n            len += offset;\n            int v = -1;\n\n            // First we need to concatenate the tail of the previous call\n            // with any input bytes available now and see if we can empty\n            // the tail.\n\n            switch (tailLen) {\n                case 0:\n                    // There was no tail.\n                    break;\n                case 1:\n                    if (p + 2 <= len) {\n                        // A 1-byte tail with at least 2 bytes of\n                        // input available now.\n                        v = ((tail[0] & 0xff) << 16) |\n                                ((input[p++] & 0xff) << 8) |\n                                (input[p++] & 0xff);\n                        tailLen = 0;\n                    }\n                    break;\n                case 2:\n                    if (p + 1 <= len) {\n                        // A 2-byte tail with at least 1 byte of input.\n                        v = ((tail[0] & 0xff) << 16) |\n                                ((tail[1] & 0xff) << 8) |\n                                (input[p++] & 0xff);\n                        tailLen = 0;\n                    }\n                    break;\n            }\n\n            if (v != -1) {\n                output[op++] = alphabet[(v >> 18) & 0x3f];\n                output[op++] = alphabet[(v >> 12) & 0x3f];\n                output[op++] = alphabet[(v >> 6) & 0x3f];\n                output[op++] = alphabet[v & 0x3f];\n                if (--count == 0) {\n                    if (do_cr) output[op++] = '\\r';\n                    output[op++] = '\\n';\n                    count = LINE_GROUPS;\n                }\n            }\n\n            // At this point either there is no tail, or there are fewer\n            // than 3 bytes of input available.\n\n            // The main loop, turning 3 input bytes into 4 output bytes on\n            // each iteration.\n            while (p + 3 <= len) {\n                v = ((input[p] & 0xff) << 16) |\n                        ((input[p + 1] & 0xff) << 8) |\n                        (input[p + 2] & 0xff);\n                output[op] = alphabet[(v >> 18) & 0x3f];\n                output[op + 1] = alphabet[(v >> 12) & 0x3f];\n                output[op + 2] = alphabet[(v >> 6) & 0x3f];\n                output[op + 3] = alphabet[v & 0x3f];\n                p += 3;\n                op += 4;\n                if (--count == 0) {\n                    if (do_cr) output[op++] = '\\r';\n                    output[op++] = '\\n';\n                    count = LINE_GROUPS;\n                }\n            }\n\n            if (finish) {\n                // Finish up the tail of the input.  Note that we need to\n                // consume any bytes in tail before any bytes\n                // remaining in input; there should be at most two bytes\n                // total.\n\n                if (p - tailLen == len - 1) {\n                    int t = 0;\n                    v = ((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 4;\n                    tailLen -= t;\n                    output[op++] = alphabet[(v >> 6) & 0x3f];\n                    output[op++] = alphabet[v & 0x3f];\n                    if (do_padding) {\n                        output[op++] = '=';\n                        output[op++] = '=';\n                    }\n                    if (do_newline) {\n                        if (do_cr) output[op++] = '\\r';\n                        output[op++] = '\\n';\n                    }\n                } else if (p - tailLen == len - 2) {\n                    int t = 0;\n                    v = (((tailLen > 1 ? tail[t++] : input[p++]) & 0xff) << 10) |\n                            (((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 2);\n                    tailLen -= t;\n                    output[op++] = alphabet[(v >> 12) & 0x3f];\n                    output[op++] = alphabet[(v >> 6) & 0x3f];\n                    output[op++] = alphabet[v & 0x3f];\n                    if (do_padding) {\n                        output[op++] = '=';\n                    }\n                    if (do_newline) {\n                        if (do_cr) output[op++] = '\\r';\n                        output[op++] = '\\n';\n                    }\n                } else if (do_newline && op > 0 && count != LINE_GROUPS) {\n                    if (do_cr) output[op++] = '\\r';\n                    output[op++] = '\\n';\n                }\n\n                assert tailLen == 0;\n                assert p == len;\n            } else {\n                // Save the leftovers in tail to be consumed on the next\n                // call to encodeInternal.\n\n                if (p == len - 1) {\n                    tail[tailLen++] = input[p];\n                } else if (p == len - 2) {\n                    tail[tailLen++] = input[p];\n                    tail[tailLen++] = input[p + 1];\n                }\n            }\n\n            this.op = op;\n            this.count = count;\n\n            return true;\n        }","location":{"start":609,"insert":609,"offset":" ","indent":8,"comment":null},"item_type":"method","length":133,"docLength":null}]}}}